
/*
 * Header file generation.
 * 
 * Generate a publicly accessible RenderWare header file from the
 * internal module headers. This utility parses all files + dependants 
 * from the command line and extracts all data bracketed by
 * RWPUBLIC and RWPUBLICEND keywords held in comments. 
 *
 * Usage: incgen [options]
 *
 * Options are:
 *
 * -i<dirspec>
 * -I<dirspec>
 *     Specify include directory to find dependency files, eg -I./src
 * -o<filespec>
 *     Specify output filename, eg -orwcore.h
 * -s<filespec>
 *     Specify system filename to #include, eg -sstdio.h
 * -g<filespec>
 *     Write guard that generated file is included before this one, eg -grwcore.h.
 * -v
 *     Verbose mode on - prints out extra debug info, like dependencies found.
 * -l<filespec>
 *     Specify list output file - produces a list of the files included in the
 *     generated file.
 * -x<filespec>
 *     Specify exclude input file - rejects files listed in this file - should be
 *     early in the options order.
 * -r<filespec>
 *     Remove single file from the reject list.  Should appear in options list
 *     after the file has been added to the reject list.
 * <filespec>
 *     Other non -options are files to start with - add *.h files you want to parse
 *     using.
 * -p<rpefile>
 *     Specify name of rpe file - produces a '#include <rpefile>.rpe' at the top
 *     of the produced file.
 *
 * This comment is generated by the RCS co command:
 * $Id: main.c,v 1.9 2000/10/02 14:11:35 johns Exp $
 * <file name> <rev> <date & time> <author> <state> <currently locked by>
 */
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>
#include <ctype.h>

#include "main.h"

/*--- Structure Definitions ---*/

/* Simple Linked List structure. This structure along with supporting 
 * functions provides generic linked list management for lists of filenames 
 */

typedef struct stLink TyLink;
struct stLink
{
	char               *name;
	TyLink             *next;
	TyLink             *prev;
};

/* Extended linked list structure to support dependancy lists. 
 * Note: the link member must be the first member in order for the generic
 * linked list functions to operate on this structure.
 */

typedef struct stFileLink TyFileLink;
struct stFileLink
{
	TyLink              link;
	TyLink             *child;
	int                 childCount;
};

/*--- Global Variables ---*/

static TyFileLink  *FileList = NULL; /* list of all files from command 

                                      * 
                                      * * line and dependencies 
                                      */
static TyFileLink  *RejectFileList = NULL; /* List of all the files that must

                                            * 
                                            * * not be added to the process list
                                            */
static TyFileLink  *CurrentFile = NULL; /* current file being processed */
static TyLink      *PathList = NULL; /* Search path for included files */
static TyLink      *GuardList = NULL; /* List of files that must be included

                                       * 
                                       * * before this one
                                       */
static TyLink      *SysList = NULL; /* list of system files to be added */
static int          Verbose = 0; /* print verbose information */
static char        *OutFileName = NULL; /* Output filename */
static char        *RpeFileName = NULL; /* Name of RPE file to include */

/******************************************************************************
 *
 * Add a new element to a linked list.
 *
 *****************************************************************************/
static TyLink      *
NewLink(TyLink * start, char *name, int size)
{
	TyLink             *newLink = malloc(size);

	newLink->name = name;
	newLink->next = start;
	newLink->prev = NULL;
	if (start)
	{
		start->prev = newLink;
	}
	return (newLink);
}

/******************************************************************************
 *
 * Find a named element in a linked list.
 *
 *****************************************************************************/
static TyLink      *
FindLink(TyLink * start, char *name)
{
	TyLink             *cur;

	for (cur = start; cur; cur = cur->next)
	{
		if (!stricmp(cur->name, name))
		{
			return (cur);
		}
	}
	return (NULL);
}

/******************************************************************************
 *
 * Remove an element from a linked list
 *
 *****************************************************************************/
static TyLink      *
RemoveLink(TyLink * start, TyLink * link)
{
	TyLink             *next = link->next;

	if (link->prev)
	{
		link->prev->next = link->next;
	}
	if (link->next)
	{
		link->next->prev = link->prev;
	}

	free(link);

	if (start == link)
	{
		/* start link removed */
		return (next);
	}
	else
	{
		return (start);
	}
}











/*************************************************************************
 *
 * Add a new filename to the list of all dependencies.
 *
 *************************************************************************/

static void
NewFile(char *name)
{
#ifdef RWDEBUG
    printf("New File: %s\n", name);
#endif

	FileList =
		(TyFileLink *) NewLink((TyLink *) FileList, name, sizeof(TyFileLink));
	FileList->child = NULL;
	FileList->childCount = 0;
}

/*************************************************************************
 *
 * Check if the supplied filename exists already. If not then add a new 
 * filename to the list of all dependencies.
 *
 *************************************************************************/
void
AddFile(char *name)
{
	if (name)
	{
		if (FindLink((TyLink *) RejectFileList, name))
		{
			/* Reject the filename, 'cos it's on the reject list */
			free(name);
			return;
		}
		if (FindLink((TyLink *) FileList, name))
		{
			/* Filename already exists on this list - we don't need it again */
			free(name);
			return;
		}
		NewFile(name);
	}
}

/*************************************************************************
 *
 * Add a new filename to the list of files to reject.
 *
 *************************************************************************/

static void
NewRejectFile(char *name)
{
#ifdef RWDEBUG
    printf("New Reject File: %s\n", name);
#endif

	RejectFileList =
		(TyFileLink *) NewLink((TyLink *) RejectFileList, name,
							   sizeof(TyFileLink));
	RejectFileList->child = NULL;
	RejectFileList->childCount = 0;
}

/*************************************************************************
 *
 * Check if the supplied filename exists already. If not then add a new 
 * filename to the list of all files to reject.
 *
 *************************************************************************/
void
AddRejectFile(char *name)
{
	if (name)
	{
		if (FindLink((TyLink *) RejectFileList, name))
		{
			/* Filename already exists */
			free(name);
			return;
		}
		NewRejectFile(name);
	}
}







/*************************************************************************
 *
 * Add a new directory to the search path for include files
 *
 ************************************************************************/
static void
AddPath(char *name)
{
	char               *newName = malloc(strlen(name) + 1);

	strcpy(newName, name);

	PathList = NewLink(PathList, newName, sizeof(TyLink));
}






/*************************************************************************
 *
 * Get the base of the name
 *
 ************************************************************************/

static char        *
ExtractBase(char *inName)
{
	char               *processBuf, *outName;
	int                 i;

	processBuf = malloc(strlen(inName) + 1);
	strcpy(processBuf, inName);

	/* extract base of filename */
	for (i = strlen(processBuf); i >= 0; i--)
	{
		if (processBuf[i] == '.')
		{
			processBuf[i] = '\0';
		}
		if ((processBuf[i] == '\\') || (processBuf[i] == '/'))
		{
			break;
		}
		processBuf[i] = toupper(processBuf[i]);
	}
	i++;

	outName = malloc(strlen(&processBuf[i]) + 1);
	strcpy(outName, &processBuf[i]);
	free(processBuf);

	return (outName);
}

/*************************************************************************
 *
 * Print output file header
 *
 ************************************************************************/
static void
PrintHeader(FILE * fp)
{
	time_t              ltime;

	time(&ltime);

	fprintf(fp, "/******************************************/\n");
	fprintf(fp, "/*                                        */\n");
	fprintf(fp, "/*    RenderWare(TM) Graphics Library     */\n");
	fprintf(fp, "/*                                        */\n");
	fprintf(fp, "/******************************************/\n");
	fprintf(fp, "\n");
	fprintf(fp, "/*\n");
	fprintf(fp, " * This file is a product of Criterion Software Ltd.\n");
	fprintf(fp, " *\n");
	fprintf(fp,
			" * This file is provided as is with no warranties of any kind and is\n");
	fprintf(fp,
			" * provided without any obligation on Criterion Software Ltd.\n");
	fprintf(fp, " * or Canon Inc. to assist in its use or modification.\n");
	fprintf(fp, " *\n");
	fprintf(fp,
			" * Criterion Software Ltd. and Canon Inc. will not, under any\n");
	fprintf(fp,
			" * circumstances, be liable for any lost revenue or other damages\n");
	fprintf(fp, " * arising from the use of this file.\n");
	fprintf(fp, " *\n");
	fprintf(fp, " * Copyright (c) 1999. Criterion Software Ltd.\n");
	fprintf(fp, " * All Rights Reserved.\n");
	fprintf(fp, " */\n");
	fprintf(fp, "\n");

	fprintf(fp,
			"/*************************************************************************\n");
	fprintf(fp, " *\n");

	if (OutFileName)
	{
		fprintf(fp, " * Filename: <%s>\n", OutFileName);
	}
	else
	{
		fprintf(fp, " * Filename: <unknown>\n");
	}
	fprintf(fp, " * Automatically Generated on: %s", ctime(&ltime));
	fprintf(fp, " *\n");
	fprintf(fp,
			" ************************************************************************/\n");
	fprintf(fp, "\n");

	if (OutFileName)
	{
		char               *base;

		base = ExtractBase(OutFileName);
		fprintf(fp, "#ifndef %s_H\n", base);
		fprintf(fp, "#define %s_H\n", base);
		fprintf(fp, "\n");
		free(base);
	}
	if (GuardList)
	{
		fprintf(fp, "/*--- Check For Previous Required Includes ---*/\n");
		while (GuardList)
		{
			char               *base;

			base = ExtractBase(GuardList->name);
			fprintf(fp, "#ifndef %s_H\n", base);
			fprintf(fp, 
					"#error \"Include %s.H before including this file\"\n",
					base);
			fprintf(fp, "#endif /* %s_H */\n", base);
			fprintf(fp, "\n");
			GuardList = RemoveLink(GuardList, GuardList);

			free(base);
		}
	}
	if (SysList)
	{
		fprintf(fp, "/*--- System Header Files ---*/\n");
		while (SysList)
		{
			fprintf(fp, "#include <%s.h>", SysList->name);
			SysList = RemoveLink(SysList, SysList);
		}
		fprintf(fp, "\n");
	}
	if (RpeFileName)
	{
		fprintf(fp, "/*--- Error enumerations ---*/\n");
		fprintf(fp, "#include \"%s.rpe\"\n", RpeFileName);
		fprintf(fp, "\n");
	}
}

/*************************************************************************
 *
 * Print output file footer
 *
 ************************************************************************/
static void
PrintFooter(FILE * fp)
{
	if (OutFileName)
	{
		char               *base;

		base = ExtractBase(OutFileName);
		fprintf(fp, "#endif /* %s_H */\n", base);
	}
}

/*************************************************************************
 *
 * Main entry point
 *
 * The following command line options are supported
 *   
 *     -v            Verbose mode
 *     -o<filename>  Output file
 *     -i<path>      Path to be added to include search path
 *
 * All other parameters are assumed to be input files
 *
 ************************************************************************/
int
main(int argc, char **argv)
{
	FILE               *outfp = NULL;
	FILE               *outlistfp = NULL;
	char               *name;
	TyLink             *link;
	FILE               *fp;

	++argv, --argc;            /* skip over program name */

	while (argc--)
	{
    	if (argv[0][0] == '-')
    	{
    		/* Option */
			switch (argv[0][1])
			{
				case 'i':
				case 'I':
					/* Include path to look for files at */
					AddPath(&(argv[0][2]));
					break;

				case 'o':
					/* Generated include file name */
					outfp = fopen(&argv[0][2], "w");
					if (!outfp)
					{
						fprintf(stderr,
								"Unable to open output file <%s>\n",
								&argv[0][2]);
						if (outlistfp)
						{
							fclose(outlistfp);
							outlistfp = NULL;
						}
						exit(1);
					}
					OutFileName = malloc(strlen(&argv[0][2]) + 1);
					strcpy(OutFileName, &argv[0][2]);
					break;

				case 's':
					/* System file to include */
					name = malloc(strlen(&argv[0][2]) + 1);
					strcpy(name, &argv[0][2]);
					SysList = NewLink(SysList, name, sizeof(TyLink));
					break;

				case 'g':
					/* Guard that this file is included first */
					name = malloc(strlen(&argv[0][2]) + 1);
					strcpy(name, &argv[0][2]);
					GuardList = NewLink(GuardList, name, sizeof(TyLink));
					break;

				case 'v':
					/* Verbose enable */
					Verbose = 1;
					break;

				case 'l':
					/* List file */
					outlistfp = fopen(&argv[0][2], "w");
					if (!outlistfp)
					{
						fprintf(stderr,
								"Unable to open output list file <%s>\n",
								&argv[0][2]);
						if (outfp)
						{
							fclose(outfp);
							outfp = NULL;
						}
						exit(1);
					}
					break;

				case 'x':
					/* Exclude file - specifies file containing list of files not to add to process list */
					fp = fopen(&argv[0][2], "r");
					if (fp)
					{
						char                filename[80];

						while (fgets(filename, 80, fp)
							   && strlen(filename) > 0)
						{
							char               *newName;
							int                 i;
						
							i = 0;
							while (isprint(filename[i]))
							{
								i++;
							}
							filename[i] = 0;

							newName = malloc(strlen(filename) + 1);
							strcpy(newName, filename);

							AddRejectFile(newName);
						}

						fclose(fp);
					}
					break;
				case 'r':
					name = &(argv[0][2]);
					link = FindLink((TyLink *) RejectFileList, name);
					if (link)
					{
						RejectFileList =
							(TyFileLink *) RemoveLink((TyLink *)
													  RejectFileList, link);
					}
					break;
				case 'p':
					/* Name of rpe file */
					RpeFileName = malloc(strlen(&argv[0][2]) + 1);
					strcpy(RpeFileName, &argv[0][2]);
					break;
				default:
					/* Ignore unknown options */
					break;
			}
			argv++;
		}
		else
		{
			/* 
             * not an option therefore must be a filename.
             * Add it to the global list of filenames
             */
            fp = fopen(*argv, "r");
            if (fp)
            {
            	name = malloc(strlen(*argv) + 1);
            	strcpy(name, *argv);
            	AddFile(name);
            	fclose(fp);
            }
            else
            {
            	fprintf(stderr, "Unable to Open: %s\n", *argv);
			}
			argv++;
		}
	}

	if (!outfp)
	{
		/* No output filename specified - use stdout */
		outfp = stdout;
	}

	if (!FileList)
	{
		fprintf(stderr, "No Files to process\n");
		exit(1);
	}

    /* Parse all files in global file list to extract dependancies.
     * This uses a simple FLEX lexical analyser for parsing
     * Note: We start at the end of the list and work backwards. This is
     * in order that new files can be added to the start of the list in the
     * usual manner and will be processed when encountered.
     */

	/* go to end of list */
    for (CurrentFile = FileList;
        CurrentFile->link.next;
		CurrentFile = (TyFileLink *) CurrentFile->link.next)
    	;




	return (0);
}
